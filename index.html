<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>opera_sonic · WebGPU Demo</title>
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<style>
		:root, body {
			margin: 0;
			height: 100%;
			background: #050505;
			color: #f0f0f0;
			font-family: system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif;
		}

		canvas {
			display: block;
			width: 100vw;
			height: 100vh;
		}

		.field-group {
			display: flex;
			flex-direction: column;
			gap: 0.4rem;
			font-size: 0.85rem;
		}

		#picker-grid {
			position: relative;
			width: min(300px, 100%);
			aspect-ratio: 1;
			border-radius: 0.5rem;
			border: 1px solid rgba(255, 255, 255, 0.18);
			background:
				radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0), transparent 55%), /* idk why but removing this breaks it */
				linear-gradient(90deg, rgba(255, 255, 255, 0.06) 1px, transparent 1px),
				linear-gradient(0deg, rgba(255, 255, 255, 0.06) 1px, transparent 1px);
			background-size: 140% 140%, 20px 20px, 20px 20px;
			box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.55);
			cursor: grab;
			user-select: none;
			touch-action: none;
			overflow: hidden;
		}

		#picker-grid.dragging {
			cursor: grabbing;
		}

		#picker-dot {
			position: absolute;
			width: 0.9rem;
			height: 0.9rem;
			border-radius: 50%;
			background: #e8ecff;
			box-shadow: 0 0 0.4rem rgba(229, 233, 255, 0.8);
			transform: translate(-50%, -50%);
			pointer-events: none;
		}
		#control-panel {
			position: fixed;
			top: 1.25rem;
			right: 1.25rem;
			width: min(250px, 92vw);
			background: rgba(12, 12, 22, 0.2);
			border: 1px solid rgba(255, 255, 255, 0.08);
			border-radius: 1rem;
			padding: 1.25rem 1.5rem;
			backdrop-filter: blur(12px);
			box-shadow: 0 20px 45px rgba(0, 0, 0, 0.55);
			pointer-events: auto;
			z-index: 5;
			display: flex;
			flex-direction: column;
			gap: 1rem;
		}

		.field-label {
			font-size: 0.8rem;
			font-weight: 600;
			letter-spacing: 0.02em;
			color: rgba(255, 255, 255, 0.7);
		}

		.file-picker {
			display: flex;
			align-items: center;
			padding-top: 0.35rem;
			
			border-radius: 0.65rem;
		}

		.file-picker input[type="file"] {
			flex-shrink: 0;
			color: transparent;
			width: auto;
		}

		.file-picker input[type="file"]::file-selector-button,
		.file-picker input[type="file"]::-webkit-file-upload-button {
			background: rgba(255, 255, 255, 0.08);
			border: 1px solid rgba(255, 255, 255, 0.12);
			border-radius: 0.5rem;
			color: #f8f8ff;
			padding: 0.4rem 0.9rem;
			cursor: pointer;
			letter-spacing: 0.05em;
			font-size: 0.7rem;
		}

		.file-meta {
			font-size: 0.75rem;
			color: rgba(255, 255, 255, 0.65);
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.cover-art-wrapper {
			position: relative;
			width: 100%;
			aspect-ratio: 1;
			border-radius: 0.75rem;
			border: 1px solid rgba(255, 255, 255, 0.12);
			background: rgba(255, 255, 255, 0.03);
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
		}

		.cover-art-wrapper img {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
			display: none;
		}

		.cover-art-placeholder {
			font-size: 0.75rem;
			color: rgba(255, 255, 255, 0.5);
			text-align: center;
			padding: 1.5rem 0.5rem;
		}

		.cover-art-wrapper.has-art img {
			display: block;
		}

		.cover-art-wrapper.has-art .cover-art-placeholder {
			display: none;
		}

		@media (max-width: 600px) {
			#control-panel {
				position: static;
				width: auto;
				margin: 0.75rem;
				padding: 1rem;
			}
		}
	</style>
</head>
<body>
	<canvas id="webgpu" height="767" width="969"></canvas>
	<div id="control-panel">
		<div class="field-group">
			<label class="field-label" for="audio-upload">Audio Source</label>
			<div class="file-picker">
				<input type="file" id="audio-upload" accept="audio/*">
				<span class="file-meta" id="audio-file-name" style="margin-left: -60%;">No file selected</span>
			</div>
		</div>
		<div class="field-group">
			<span class="field-label">Cover Art</span>
			<div id="cover-art-wrapper" class="cover-art-wrapper" aria-live="polite">
				<img id="cover-art-image" alt="Album cover art preview">
				<span id="cover-art-placeholder" class="cover-art-placeholder">No cover art detected</span>
			</div>
		</div>
		<div class="field-group">
			<span class="field-label">Color</span>
			<div id="picker-grid" tabindex="0" aria-label="2D picker" role="slider" aria-valuemin="0" aria-valuemax="1">
				<div id="picker-dot"></div>
			</div>
		</div>
	</div>
	<div id="fallback" style="display: none;">
		<p>Your browser does not support WebGPU yet. Try Chrome 113+, Edge 113+, or another WebGPU-capable browser with the <code>--enable-unsafe-webgpu</code> flag.</p>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/vibrant.js/1.0.0/Vibrant.min.js" integrity="sha512-V6rhYmJy8NZQF8F0bhJiTM0iI6wX/FKJoWvYrCM15UIeb6p38HjvTZWfO0IxJnMZrHWUJZJqLuWK0zslra2FVw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

	<script type="module">
		const canvas = document.getElementById('webgpu');
		const fallback = document.getElementById('fallback');
		const audioUploadInput = document.getElementById('audio-upload');
		const audioFileNameLabel = document.getElementById('audio-file-name');
		const pickerGrid = document.getElementById('picker-grid');
		const pickerDot = document.getElementById('picker-dot');
		const coverArtWrapper = document.getElementById('cover-art-wrapper');
		const coverArtImage = document.getElementById('cover-art-image');
		const coverArtPlaceholder = document.getElementById('cover-art-placeholder');

		if (!('gpu' in navigator)) {
			fallback.style.display = 'flex';
			canvas.style.display = 'none';
			throw new Error('WebGPU not available');
		}

		const FFT_WIDTH = 512;
		const FFT_HEIGHT = 64;
		const uniformArrayBuffer = new ArrayBuffer(64);
		const uniformFloats = new Float32Array(uniformArrayBuffer);
		const pointer = { x: 0.5, y: 0.5 };
		const easedPointer = { x: pointer.x, y: pointer.y };
		const POINTER_EASE = 0.01;
		let audioContext;
		let analyser;
		let audioSourceNode;
		let audioElement;
		let audioObjectUrl;
		let audioFrequencyData;
		let useAudioData = false;
		let coverArtObjectUrl;

		// i found an analytic solution but it was more prone to weird artifacts if the color wasn't exactly in the space, so i opted for brute-force instead
		function invert(rt, gt, bt) {
			function calc(x, y) {
				const h = 2.01 + 3.0 * x;
				const s = 0.2 + 1.0 * y;
				const a = (Math.cos(h - s) + 1.0) / 0.6;
				const b = (Math.cos(h) + 1.0) / 0.6;
				const c = (Math.cos(h + s) + 1.0) / 0.6;
				return [a, b, c];
			}

			let bestX = 0, bestY = 0;
			let bestErr = Infinity;

			const [lt, at, bt2] = customToLab(rt, gt, bt);

			for (let i = 0; i <= 100; i++) {
				const x = i / 100;
				for (let j = 0; j <= 100; j++) {
				const y = j / 100;

				const [l, a, b] = customToLab(...calc(x, y));
				const err = Math.pow((l - lt), 2) + Math.pow((a - at), 2) + Math.pow((b - bt2), 2);

				if (err < bestErr) {
					bestErr = err;
					bestX = x;
					bestY = y;
				}
				}
			}

			return { x: bestX, y: bestY, error: bestErr };
		}

		// [00, ff] -> [0, 255]
		function hexToRGB(hex) {
			hex = hex.replace(/^#/, '').toLowerCase();
			const r = parseInt(hex.slice(0, 2), 16);
			const g = parseInt(hex.slice(2, 4), 16);
			const b = parseInt(hex.slice(4, 6), 16);
			return [r, g, b];
		}

		function rgbToHex(r, g, b) {
			const toHex = (v) => {
				const h = v.toString(16);
				return h.length === 1 ? '0' + h : h;
			};
			return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
		}

		function hexToCustom(hex) {
			let [r, g, b] = hexToRGB(hex);
			return [r / 255 * 2, g / 255 * 2, b / 255 * 2];
		}

		// https://www.image-engineering.de/library/technotes/958-how-to-convert-between-srgb-and-ciexyz
		function customToXYZ(r, g, b) {
			let vals = [r, g, b].map(v => v/2);
			
			vals.map(v => {
				if (v <= 0.04045) {
					return v/12.91;
				} else {
					return Math.pow((v+0.055)/1.055, 2.4);
				}
			})

			let res = []
			res[0] = 0.4124564 * vals[0] + 0.3575761 * vals[1] + 0.1804375 * vals[2];
			res[1] = 0.2126729 * vals[0] + 0.7151522 * vals[1] + 0.0721750 * vals[2];
			res[2] = 0.0193339 * vals[0] + 0.1191920 * vals[1] + 0.9503041 * vals[2];

			return res;
		}

		// https://en.wikipedia.org/wiki/CIELAB_color_space#From_CIE_XYZ_to_CIELAB
		function xyzToLAB(x, y, z) {
			function f(t) {
				const d = 6/29;
				if (t > Math.pow(d, 3)) {
					return Math.cbrt(t);
				} else {
					return t/(3*d*d) + 4/29;
				}
			}

			return [116*f(y/100)-16, 500*(f(x/95.0489)-f(y/100)), 200*(f(y/100)-f(z/108.8840))];
		}

		function customToLab(r, g, b) {
			const [x, y, z] = customToXYZ(r, g, b);
			return xyzToLAB(x, y, z);
		}

		function clamp(value) {
			return Math.min(1, Math.max(0, value));
		}

		function setAudioFileLabel(text = 'No file selected') {
			if (audioFileNameLabel) {
				audioFileNameLabel.textContent = text;
			}
		}

		function resetCoverArtUI(message = 'No cover art detected') {
			if (!coverArtWrapper) {
				return;
			}
			if (coverArtObjectUrl) {
				URL.revokeObjectURL(coverArtObjectUrl);
				coverArtObjectUrl = undefined;
			}
			if (coverArtImage) {
				coverArtImage.removeAttribute('src');
				coverArtImage.hidden = true;
			}
			coverArtWrapper.classList.remove('has-art');
			if (coverArtPlaceholder) {
				coverArtPlaceholder.textContent = message;
			}
		}

		function showCoverArtPreview(art) {
			if (!coverArtWrapper || !coverArtImage || !art) {
				return;
			}
			if (coverArtObjectUrl) {
				URL.revokeObjectURL(coverArtObjectUrl);
			}
			const blob = new Blob([art.binary], { type: art.mimeType || 'image/jpeg' });
			coverArtObjectUrl = URL.createObjectURL(blob);
			coverArtImage.src = coverArtObjectUrl;
			coverArtImage.alt = art.description || 'Album cover art preview';
			coverArtImage.hidden = false;
			coverArtWrapper.classList.add('has-art');
			if (coverArtPlaceholder) {
				coverArtPlaceholder.textContent = art.description || 'Embedded cover art';
			}
			scheduleVibrantExtraction();
		}

		async function handleCoverArt(file) {
			if (!coverArtWrapper || !file) {
				return;
			}
			resetCoverArtUI('Looking for cover art…');
			try {
				const art = await extractCoverArt(file);
				if (art) {
					showCoverArtPreview(art);
					return;
				}
			} catch (error) {
				console.warn('Cover art extraction failed', error);
			}
			resetCoverArtUI('No cover art detected');
		}

		async function extractCoverArt(file) {
			const headerBuffer = await file.slice(0, 10).arrayBuffer();
			const headerBytes = new Uint8Array(headerBuffer);
			if (headerBytes.length < 10 || headerBytes[0] !== 0x49 || headerBytes[1] !== 0x44 || headerBytes[2] !== 0x33) {
				return null;
			}
			const tagSize = decodeSynchsafe(headerBytes.subarray(6, 10));
			if (!tagSize) {
				return null;
			}
			const totalSize = Math.min(tagSize + 10, file.size);
			const tagBuffer = await file.slice(0, totalSize).arrayBuffer();
			const tagBytes = new Uint8Array(tagBuffer);
			return parseApicFrame(tagBytes);
		}

		function parseApicFrame(tagBytes) {
			const version = tagBytes[3];
			if (version < 3) {
				return null;
			}
			const declaredSize = decodeSynchsafe(tagBytes.subarray(6, 10)) + 10;
			const tagLimit = Math.min(tagBytes.length, declaredSize);
			let offset = 10;
			const flags = tagBytes[5];
			if ((flags & 0x40) !== 0) {
				if (version === 4 && offset + 4 <= tagLimit) {
					const extSize = decodeSynchsafe(tagBytes.subarray(offset, offset + 4));
					offset += 4 + extSize;
				} else if (version === 3 && offset + 4 <= tagLimit) {
					const extSize = readUInt32BE(tagBytes, offset);
					offset += 4 + extSize;
				}
			}
			while (offset + 10 <= tagLimit) {
				const frameId = asciiString(tagBytes.subarray(offset, offset + 4));
				const frameSize = version === 4
					? decodeSynchsafe(tagBytes.subarray(offset + 4, offset + 8))
					: readUInt32BE(tagBytes, offset + 4);
				if (!frameId.trim() || frameSize <= 0) {
					break;
				}
				const frameDataStart = offset + 10;
				const frameDataEnd = frameDataStart + frameSize;
				if (frameDataEnd > tagLimit) {
					break;
				}
				if (frameId === 'APIC') {
					const art = decodeApicFrameData(tagBytes.subarray(frameDataStart, frameDataEnd));
					if (art) {
						return art;
					}
				}
				offset = frameDataEnd;
			}
			return null;
		}

		function decodeSynchsafe(bytes) {
			let value = 0;
			for (let i = 0; i < bytes.length; i++) {
				value = (value << 7) | (bytes[i] & 0x7f);
			}
			return value;
		}

		function readUInt32BE(bytes, offset) {
			return (
				((bytes[offset] << 24) >>> 0) |
				((bytes[offset + 1] << 16) >>> 0) |
				((bytes[offset + 2] << 8) >>> 0) |
				(bytes[offset + 3] >>> 0)
			) >>> 0;
		}

		function asciiString(bytes) {
			let result = '';
			for (let i = 0; i < bytes.length; i++) {
				result += String.fromCharCode(bytes[i]);
			}
			return result;
		}

		function decodeApicFrameData(frameData) {
			if (!frameData.length) {
				return null;
			}
			let offset = 0;
			const encoding = frameData[offset];
			offset += 1;
			const mimeTerminator = frameData.indexOf(0, offset);
			const mimeEnd = mimeTerminator === -1 ? frameData.length : mimeTerminator;
			const mimeType = asciiString(frameData.subarray(offset, mimeEnd)).trim() || 'image/jpeg';
			offset = mimeTerminator === -1 ? frameData.length : mimeEnd + 1;
			if (offset >= frameData.length) {
				return null;
			}
			offset += 1; // skip picture type byte
			if (offset > frameData.length) {
				return null;
			}
			const isUtf16 = encoding === 1 || encoding === 2;
			const descTerminator = findTerminatorIndex(frameData, offset, isUtf16 ? 2 : 1);
			const hasTerminator = descTerminator < frameData.length;
			offset = isUtf16
				? (hasTerminator ? descTerminator + 2 : frameData.length)
				: (hasTerminator ? descTerminator + 1 : frameData.length);
			if (offset >= frameData.length) {
				return null;
			}
			return {
				mimeType,
				description: '',
				binary: frameData.subarray(offset),
			};
		}

		function findTerminatorIndex(bytes, start, step) {
			if (step === 2) {
				for (let i = start; i + 1 < bytes.length; i += 2) {
					if (bytes[i] === 0 && bytes[i + 1] === 0) {
						return i;
					}
				}
				return bytes.length;
			}
			for (let i = start; i < bytes.length; i++) {
				if (bytes[i] === 0) {
					return i;
				}
			}
			return bytes.length;
		}

		function scheduleVibrantExtraction() {
			if (!coverArtImage) {
				return;
			}
			if (coverArtImage.complete && coverArtImage.naturalWidth > 0) {
				logVibrantSwatch();
			} else {
				coverArtImage.addEventListener('load', logVibrantSwatch, { once: true });
			}
		}

		function logVibrantSwatch() {
			if (!coverArtImage || !coverArtImage.src) {
				return;
			}
			if (typeof Vibrant === 'undefined') {
				console.warn('Vibrant.js is not available; skipping color extraction.');
				return;
			}
			try {
				const vibrant = new Vibrant(coverArtImage);
				const swatches = vibrant.swatches();
				const vibrantSwatch = swatches && swatches.Vibrant;
				if (vibrantSwatch) {
					const newP = invert(...hexToCustom(vibrantSwatch.getHex()));
					setPointerFromRelative(newP.x, newP.y);
				} else {
					console.log('Cover art processed but no vibrant swatch detected.');
				}
			} catch (error) {
				console.warn('Vibrant color extraction failed', error);
			}
		}

		resetCoverArtUI();
		window.addEventListener('beforeunload', () => {
			if (coverArtObjectUrl) {
				URL.revokeObjectURL(coverArtObjectUrl);
			}
		});

		function updatePickerDot() {
			if (!pickerDot) {
				return;
			}
			pickerDot.style.left = `${pointer.x * 100}%`;
			pickerDot.style.top = `${pointer.y * 100}%`;

			if (pickerGrid) {
				pickerGrid.setAttribute('aria-valuetext', `X ${pointer.x.toFixed(2)}, Y ${pointer.y.toFixed(2)}`);
			}
		}

		function setPointerFromRelative(relX, relY) {
			pointer.x = clamp(relX);
			pointer.y = clamp(relY);
			uniformFloats[10] = pointer.x;
			uniformFloats[11] = pointer.y;
			updatePickerDot();
		}

		function pointerEventToRelative(event) {
			if (!pickerGrid) {
				return { x: pointer.x, y: pointer.y };
			}
			const rect = pickerGrid.getBoundingClientRect();
			const relX = clamp((event.clientX - rect.left) / rect.width);
			const relY = clamp((event.clientY - rect.top) / rect.height);
			return { x: relX, y: relY };
		}

		async function setupAudioFromFile(file) {
			try {
				if (!file) {
					return;
				}
				if (!audioContext) {
					audioContext = new (window.AudioContext || window.webkitAudioContext)();
				}
				if (audioElement) {
					audioElement.pause();
					audioElement.src = '';
				}
				if (audioSourceNode) {
					audioSourceNode.disconnect();
					audioSourceNode = undefined;
				}
				if (analyser) {
					analyser.disconnect();
					analyser = undefined;
				}
				if (audioObjectUrl) {
					URL.revokeObjectURL(audioObjectUrl);
					audioObjectUrl = undefined;
				}
				audioObjectUrl = URL.createObjectURL(file);
				audioElement = new Audio();
				audioElement.src = audioObjectUrl;
				audioElement.loop = true;
				audioElement.crossOrigin = 'anonymous';
				audioSourceNode = audioContext.createMediaElementSource(audioElement);
				analyser = audioContext.createAnalyser();
				analyser.fftSize = FFT_WIDTH * 2;
				analyser.smoothingTimeConstant = 0.8;
				audioSourceNode.connect(analyser);
				analyser.connect(audioContext.destination);
				audioFrequencyData = new Uint8Array(analyser.frequencyBinCount);
				await audioContext.resume();
				await audioElement.play();
				useAudioData = true;
			} catch (error) {
				console.error('Audio setup failed', error);
				useAudioData = false;
			}
		}
		if (pickerGrid) {
			const KEY_STEP = 0.02;
			let isDraggingPicker = false;
			pickerGrid.addEventListener('pointerdown', (event) => {
				event.preventDefault();
				pickerGrid.setPointerCapture(event.pointerId);
				isDraggingPicker = true;
				pickerGrid.classList.add('dragging');
				const { x, y } = pointerEventToRelative(event);
				setPointerFromRelative(x, y);
			});
			pickerGrid.addEventListener('pointermove', (event) => {
				if (!isDraggingPicker) {
					return;
				}
				const { x, y } = pointerEventToRelative(event);
				setPointerFromRelative(x, y);
			});
			const endDrag = (event) => {
				if (!isDraggingPicker) {
					return;
				}
				isDraggingPicker = false;
				pickerGrid.classList.remove('dragging');
				if (pickerGrid.hasPointerCapture(event.pointerId)) {
					pickerGrid.releasePointerCapture(event.pointerId);
				}
			};
			pickerGrid.addEventListener('pointerup', endDrag);
			pickerGrid.addEventListener('pointercancel', endDrag);
			pickerGrid.addEventListener('keydown', (event) => {
				let handled = true;
				switch (event.key) {
					case 'ArrowLeft':
						setPointerFromRelative(pointer.x - KEY_STEP, pointer.y);
						break;
					case 'ArrowRight':
						setPointerFromRelative(pointer.x + KEY_STEP, pointer.y);
						break;
					case 'ArrowUp':
						setPointerFromRelative(pointer.x, pointer.y - KEY_STEP);
						break;
					case 'ArrowDown':
						setPointerFromRelative(pointer.x, pointer.y + KEY_STEP);
						break;
					case 'Home':
						setPointerFromRelative(0, 0);
						break;
					case 'End':
						setPointerFromRelative(1, 1);
						break;
					default:
						handled = false;
				}
				if (handled) {
					event.preventDefault();
				}
			});
		}
		if (audioUploadInput) {
			audioUploadInput.addEventListener('change', async (event) => {
				const target = event.target;
				if (!(target instanceof HTMLInputElement)) {
					return;
				}
				const file = target.files && target.files[0];
				if (file) {
					setAudioFileLabel(file.name);
					const audioPromise = setupAudioFromFile(file);
					const artPromise = handleCoverArt(file);
					await Promise.allSettled([audioPromise, artPromise]);
					target.value = '';
				} else {
					setAudioFileLabel();
					resetCoverArtUI();
				}
			});
		}

		setPointerFromRelative(pointer.x, pointer.y);

		async function loadShaderSource(path) {
			const response = await fetch(path);
			if (!response.ok) {
				throw new Error(`Failed to load ${path}: ${response.status}`);
			}
			return response.text();
		}

		async function init() {
			const adapter = await navigator.gpu.requestAdapter();
			if (!adapter) {
				throw new Error('No suitable GPU adapter found');
			}
			const device = await adapter.requestDevice();
			const context = canvas.getContext('webgpu');
			const format = navigator.gpu.getPreferredCanvasFormat();

			function configureContext() {
				const dpr = window.devicePixelRatio || 1;
				const width = Math.max(1, Math.floor(canvas.clientWidth * dpr));
				const height = Math.max(1, Math.floor(canvas.clientHeight * dpr));
				if (canvas.width !== width || canvas.height !== height) {
					canvas.width = width;
					canvas.height = height;
				}
				context.configure({
					device,
					format,
					alphaMode: 'opaque',
					usage: GPUTextureUsage.RENDER_ATTACHMENT,
					size: { width, height },
				});
				uniformFloats[12] = width;
				uniformFloats[13] = height;
			}

			configureContext();
			window.addEventListener('resize', configureContext);

			const [vertexSource, fragmentSource] = await Promise.all([
				loadShaderSource('./vert.wgsl'),
				loadShaderSource('./frag.wgsl'),
			]);

			const vertexModule = device.createShaderModule({ code: vertexSource });
			const fragmentModule = device.createShaderModule({ code: fragmentSource });

			const vertices = new Float32Array([
				-1, -1,
				1, -1,
				1,  1,
				-1, -1,
				1,  1,
				-1,  1,
			]);

			const vertexBuffer = device.createBuffer({
				size: vertices.byteLength,
				usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
				mappedAtCreation: true,
			});
			new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
			vertexBuffer.unmap();

			const uniformBuffer = device.createBuffer({
				size: uniformArrayBuffer.byteLength,
				usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
			});

			uniformFloats[10] = easedPointer.x;      // picker.x
			uniformFloats[11] = easedPointer.y;      // picker.y
			uniformFloats[12] = canvas.width;
			uniformFloats[13] = canvas.height;
			device.queue.writeBuffer(uniformBuffer, 0, uniformArrayBuffer);

			const fftTexture = device.createTexture({
				size: { width: FFT_WIDTH, height: FFT_HEIGHT },
				format: 'rgba32float',
				usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
			});

			const fftSampler = device.createSampler({
				addressModeU: 'repeat',
				addressModeV: 'repeat',
				magFilter: 'nearest',
				minFilter: 'nearest',
			});

			const fftData = new Float32Array(FFT_WIDTH * FFT_HEIGHT * 4);
			const bytesPerRow = FFT_WIDTH * Float32Array.BYTES_PER_ELEMENT * 4;
			function updateFFT() {
				if (useAudioData && analyser && audioFrequencyData) {
					analyser.getByteFrequencyData(audioFrequencyData);
					for (let y = 0; y < FFT_HEIGHT; y++) {
						for (let x = 0; x < FFT_WIDTH; x++) {
							const freqIndex = Math.min(x, audioFrequencyData.length - 1);
							const amp = audioFrequencyData[freqIndex] / 255;
							const idx = (y * FFT_WIDTH + x) * 4;
							fftData[idx] = amp*0.6;
						}
					}
				} else {
					fftData.fill(0);
				}
				device.queue.writeTexture(
					{ texture: fftTexture },
					fftData,
					{ bytesPerRow, rowsPerImage: FFT_HEIGHT },
					{ width: FFT_WIDTH, height: FFT_HEIGHT }
				);
			}

			const uniformsBindGroupLayout = device.createBindGroupLayout({
				entries: [
				{
					binding: 0,
					visibility: GPUShaderStage.FRAGMENT,
					buffer: { type: 'uniform' },
				},
				],
			});

			const audioBindGroupLayout = device.createBindGroupLayout({
				entries: [
				{
					binding: 1,
					visibility: GPUShaderStage.FRAGMENT,
					texture: { sampleType: 'unfilterable-float' },
				},
				{
					binding: 2,
					visibility: GPUShaderStage.FRAGMENT,
					sampler: { type: 'non-filtering' },
				},
				],
			});

			const pipeline = device.createRenderPipeline({
				layout: device.createPipelineLayout({
				bindGroupLayouts: [uniformsBindGroupLayout, audioBindGroupLayout],
				}),
				vertex: {
				module: vertexModule,
				entryPoint: 'main',
				buffers: [
					{
					arrayStride: 8,
					attributes: [
						{ shaderLocation: 0, offset: 0, format: 'float32x2' },
					],
					},
				],
				},
				fragment: {
				module: fragmentModule,
				entryPoint: 'main',
				targets: [{ format }],
				},
				primitive: { topology: 'triangle-list' },
			});

			const uniformsBindGroup = device.createBindGroup({
				layout: uniformsBindGroupLayout,
				entries: [
				{ binding: 0, resource: { buffer: uniformBuffer } },
				],
			});

			const audioBindGroup = device.createBindGroup({
				layout: audioBindGroupLayout,
				entries: [
				{ binding: 1, resource: fftTexture.createView() },
				{ binding: 2, resource: fftSampler },
				],
			});

			function updateUniforms(timeSeconds) {
				easedPointer.x += (pointer.x - easedPointer.x) * POINTER_EASE;
				easedPointer.y += (pointer.y - easedPointer.y) * POINTER_EASE;
				uniformFloats[8] = timeSeconds*0.8;
				uniformFloats[10] = easedPointer.x;
				uniformFloats[11] = easedPointer.y;
				uniformFloats[12] = canvas.width;
				uniformFloats[13] = canvas.height;
				device.queue.writeBuffer(uniformBuffer, 0, uniformArrayBuffer);
			}

			function render(timeMs) {
				const timeSeconds = timeMs * 0.001;
				updateUniforms(timeSeconds);
				updateFFT();

				const commandEncoder = device.createCommandEncoder();
				const textureView = context.getCurrentTexture().createView();
				const passEncoder = commandEncoder.beginRenderPass({
				colorAttachments: [
					{
						view: textureView,
						clearValue: { r: 0, g: 0, b: 0, a: 1 },
						loadOp: 'clear',
						storeOp: 'store',
					},
				],
				});

				passEncoder.setPipeline(pipeline);
				passEncoder.setVertexBuffer(0, vertexBuffer);
				passEncoder.setBindGroup(0, uniformsBindGroup);
				passEncoder.setBindGroup(1, audioBindGroup);
				passEncoder.draw(6, 1, 0, 0);
				passEncoder.end();

				device.queue.submit([commandEncoder.finish()]);
				requestAnimationFrame(render);
			}

			requestAnimationFrame(render);
		}

		init().catch((error) => {
			console.error(error);
			fallback.style.display = 'flex';
			fallback.textContent = error.message;
		});
	</script>
</body>
</html>
